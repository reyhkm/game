<!DOCTYPE html>
<html lang="id">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cosmic Voyager PvP - Full Feature</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }

        #student-info {
            position: absolute;
            top: 15px;
            left: 15px;
            padding: 8px 12px;
            background-color: rgba(30, 30, 50, 0.75);
            border: 1px solid rgba(100, 100, 150, 0.8);
            border-radius: 8px;
            color: #e0e0ff;
            font-size: 1.0em;
            line-height: 1.4;
            z-index: 110;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            text-align: left;
        }

        #student-info strong {
            font-weight: bold;
            color: #f0f0ff;
        }

        #info-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            z-index: 100;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            font-size: 1.1em;
            display: none;
            gap: 15px;
            align-items: center;
        }

        #hp-bar-container {
            width: 120px;
            height: 18px;
            background-color: #555;
            border-radius: 3px;
            border: 1px solid #888;
            overflow: hidden;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.2s ease-out;
        }

        #hp-text {
            font-size: 0.8em;
            color: #fff;
            margin-left: 5px;
            white-space: nowrap;
        }

        #info {
            display: none;
        }

        #scoreboard {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 8px;
            background-color: rgba(30, 30, 50, 0.75);
            border: 1px solid rgba(100, 100, 150, 0.8);
            border-radius: 8px;
            z-index: 105;
            min-width: 180px;
            max-width: 250px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
        }

        #scoreboard h3 {
            margin-top: 0;
            margin-bottom: 5px;
            text-align: center;
            font-size: 1.1em;
        }

        #scoreboard table {
            width: 100%;
            border-collapse: collapse;
        }

        #scoreboard th,
        #scoreboard td {
            padding: 3px 6px;
            text-align: left;
            border-bottom: 1px solid rgba(100, 100, 150, 0.5);
        }

        #scoreboard th {
            background-color: rgba(50, 50, 80, 0.6);
        }

        #global-notifications {
            position: absolute;
            bottom: 60px;
            left: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            z-index: 106;
            pointer-events: none;
            max-height: 100px;
            overflow: hidden;
        }

        .notification-item {
            background-color: rgba(50, 50, 80, 0.85);
            color: #e0e0e0;
            padding: 6px 12px;
            border-radius: 5px;
            margin-bottom: 5px;
            font-size: 0.85em;
            opacity: 1;
            transition: opacity 0.5s ease-out, transform 0.3s ease-out;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .notification-item.fade-out {
            opacity: 0;
            transform: translateX(-20px);
        }

        #damage-direction-indicators {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 120px;
            height: 120px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 107;
        }

        .damage-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            opacity: 0;
            transition: opacity 0.2s ease-out;
        }

        #damage-arrow-up {
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(10px);
            border-width: 0 10px 15px 10px;
            border-color: transparent transparent rgba(255, 0, 0, 0.7) transparent;
        }

        #damage-arrow-down {
            top: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-10px);
            border-width: 15px 10px 0 10px;
            border-color: rgba(255, 0, 0, 0.7) transparent transparent transparent;
        }

        #damage-arrow-left {
            top: 50%;
            right: 100%;
            transform: translateY(-50%) translateX(10px);
            border-width: 10px 15px 10px 0;
            border-color: transparent rgba(255, 0, 0, 0.7) transparent transparent;
        }

        #damage-arrow-right {
            top: 50%;
            left: 100%;
            transform: translateY(-50%) translateX(-10px);
            border-width: 10px 0 10px 15px;
            border-color: transparent transparent transparent rgba(255, 0, 0, 0.7);
        }

        #blocker {
            position: absolute;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #blocker div {
            text-align: center;
            padding: 20px;
            background-color: rgba(50, 50, 50, 0.9);
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
        }

        #name-input-container {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
        }

        #player-name-input {
            padding: 8px 10px;
            border-radius: 4px;
            border: 1px solid #555;
            background-color: #333;
            color: #fff;
            font-size: 1em;
            width: 200px;
        }

        #player-name-input::placeholder {
            color: #888;
        }

        #submit-name-button,
        #start-game-button {
            padding: 8px 15px;
            font-size: 1em;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        #submit-name-button {
            background-color: #4CAF50;
        }

        #submit-name-button:hover {
            background-color: #45a049;
        }

        #start-game-button {
            background-color: #007bff;
            margin-top: 10px;
        }

        #start-game-button:hover {
            background-color: #0069d9;
        }

        #start-game-button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }

        #blocker div p#blocker-status-text {
            margin-top: 15px;
            font-style: italic;
            color: #ccc;
        }

        #fullscreen-button {
            margin-top: 20px;
            padding: 10px 15px;
            background-color: #337ab7;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            display: none !important;
            /* Secara default terlihat, akan disembunyikan oleh media query di mobile */
        }

        .touch-controls-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 30%;
            display: none;
            justify-content: space-between;
            align-items: flex-end;
            padding: 20px;
            box-sizing: border-box;
            pointer-events: none;
            z-index: 150;
        }

        #joystick-area {
            width: 120px;
            height: 120px;
            position: relative;
            pointer-events: auto;
            opacity: 0.6;
        }

        #joystick-base {
            width: 100%;
            height: 100%;
            background-color: rgba(100, 100, 100, 0.5);
            border-radius: 50%;
            position: absolute;
        }

        #joystick-knob {
            width: 50px;
            height: 50px;
            background-color: rgba(200, 200, 200, 0.7);
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        #shoot-button-area {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #shoot-button {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 80, 80, 0.6);
            border-radius: 50%;
            border: 2px solid rgba(255, 150, 150, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2em;
            font-weight: bold;
            user-select: none;
            -webkit-user-select: none;
        }

        #orientation-blocker {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.95);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 9999;
            padding: 20px;
            box-sizing: border-box;
        }

        #orientation-blocker p {
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        #orientation-blocker svg {
            width: 80px;
            height: 80px;
            fill: white;
            animation: rotateIcon 2s linear infinite;
        }

        @keyframes rotateIcon {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .death-message {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5em;
            color: #ff4444;
            text-shadow: 2px 2px 5px #000;
            z-index: 250;
            display: none;
            text-align: center;
        }

        .damage-indicator {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
            z-index: 9000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        @media (max-width: 768px) {
            #info-bar {
                font-size: 0.8em;
                padding: 3px 6px;
                gap: 8px;
                top: 5px;
            }

            #hp-bar-container {
                width: 80px;
                height: 14px;
            }

            #hp-text {
                font-size: 0.7em;
                margin-left: 3px;
            }

            #scoreboard {
                top: 5px;
                right: 5px;
                padding: 5px;
                font-size: 0.7em;
                min-width: 120px;
                max-width: 150px;
                max-height: 150px;
            }

            #scoreboard h3 {
                font-size: 1em;
                margin-bottom: 3px;
            }

            #scoreboard th,
            #scoreboard td {
                padding: 2px 4px;
            }

            #student-info {
                font-size: 0.75em;
                padding: 5px 8px;
                top: 5px;
                left: 5px;
            }

            .death-message {
                font-size: 1.8em;
            }

            #global-notifications {
                bottom: 80px;
                left: 5px;
                right: 5px;
                max-height: 60px;
            }

            .notification-item {
                font-size: 0.75em;
                padding: 4px 8px;
            }

            #damage-direction-indicators {
                width: 90px;
                height: 90px;
            }

            #damage-arrow-up {
                border-width: 0 8px 12px 8px;
            }

            #damage-arrow-down {
                border-width: 12px 8px 0 8px;
            }

            #damage-arrow-left {
                border-width: 8px 12px 8px 0;
            }

            #damage-arrow-right {
                border-width: 8px 0 8px 12px;
            }

            #fullscreen-button {
                display: none !important;
            }

            /* Sembunyikan tombol fullscreen di mobile */
        }

        @media (max-width: 768px) and (max-height: 450px) {
            #info-bar {
                font-size: 0.7em;
                padding: 2px 4px;
                gap: 5px;
            }

            #hp-bar-container {
                width: 60px;
                height: 12px;
            }

            #hp-text {
                font-size: 0.6em;
            }

            #scoreboard {
                font-size: 0.6em;
                min-width: 100px;
                max-width: 120px;
                max-height: 100px;
                padding: 3px;
            }

            #scoreboard h3 {
                font-size: 0.9em;
            }

            #scoreboard th,
            #scoreboard td {
                padding: 1px 2px;
            }

            #student-info {
                display: none;
            }

            #global-notifications {
                bottom: 70px;
                max-height: 50px;
            }

            .notification-item {
                font-size: 0.7em;
            }

            #damage-direction-indicators {
                width: 70px;
                height: 70px;
            }

            #damage-arrow-up {
                border-width: 0 6px 10px 6px;
            }

            #damage-arrow-down {
                border-width: 10px 6px 0 6px;
            }

            #damage-arrow-left {
                border-width: 6px 10px 6px 0;
            }

            #damage-arrow-right {
                border-width: 6px 0 6px 10px;
            }

            /* #fullscreen-button sudah di-handle oleh media query di atas */
        }
    </style>
</head>

<body>
    <div id="student-info"><strong>Reykal Hizbullah</strong><br>51422420</div>
    <div id="blocker">
        <div>
            <h1 id="blocker-title-text">Cosmic Voyager: PvP</h1>
            <div id="name-input-container"> <input type="text" id="player-name-input" placeholder="Nama Anda (3-15 kar)"
                    maxlength="15"> <button id="submit-name-button">Set Nama</button> </div>
            <p id="blocker-instruction-text">Masukkan nama.</p>
            <p id="blocker-subinstruction-text"></p>
            <p id="blocker-status-text"></p>
        </div> <button id="start-game-button" disabled>Mulai!</button> <button
            id="fullscreen-button">Fullscreen</button>
    </div>
    <div id="info-bar">
        <div id="hp-bar-container">
            <div id="hp-bar"></div>
        </div>
        <div id="hp-text">HP: 100/100</div>
        <div id="info"></div>
    </div>
    <div id="scoreboard">
        <h3>Scoreboard</h3>
        <table id="scoreboard-table">
            <thead>
                <tr>
                    <th>Nama</th>
                    <th>Kills</th>
                    <th>Deaths</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
    <div id="global-notifications"></div>
    <div id="damage-direction-indicators">
        <div class="damage-arrow" id="damage-arrow-up"></div>
        <div class="damage-arrow" id="damage-arrow-down"></div>
        <div class="damage-arrow" id="damage-arrow-left"></div>
        <div class="damage-arrow" id="damage-arrow-right"></div>
    </div>
    <div class="touch-controls-container">
        <div id="joystick-area">
            <div id="joystick-base"></div>
            <div id="joystick-knob"></div>
        </div>
        <div id="shoot-button-area">
            <div id="shoot-button">FIRE</div>
        </div>
    </div>
    <div id="orientation-blocker"> <svg viewBox="0 0 24 24">
            <path
                d="M17.65,6.35C16.2,4.9 14.21,4 12,4c-4.42,0-7.99,3.58-7.99,8s3.57,8,7.99,8c3.73,0,6.84-2.55,7.73-6h-2.08c-.82,2.33-3.04,4-5.65,4-3.31,0-6-2.69-6-6s2.69-6,6-6c1.66,0,3.14,.69,4.22,1.78L13,11h7V4l-2.35,2.35z" />
        </svg>
        <p>Putar ke Lanskap.</p>
    </div>
    <div class="death-message" id="death-message-ui">ANDA MATI!<br><span id="respawn-timer-text"></span></div>
    <div class="damage-indicator" id="damage-indicator-ui"></div>
    <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
    <script
        type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>
    <script type="module">
        import * as THREE from 'three';
        let scene, camera, renderer; let playerShip; let moveForward = false, moveBackward = false; const playerSpeed = 22.0; const playerRadius = 2.5; let shipYaw = 0, shipPitch = 0; const desktopMouseSensitivity = 0.002; const mobileLookSensitivity = 0.0028; let currentLookSensitivity = desktopMouseSensitivity; const maxPitch = Math.PI / 2.5; const minPitch = -Math.PI / 2.5; let localPlayerHp = 100; let localPlayerMaxHp = 100; const worldSize = 220; const clock = new THREE.Clock();
        const blocker = document.getElementById('blocker'); const blockerTitleText = document.getElementById('blocker-title-text'); const blockerInstructionText = document.getElementById('blocker-instruction-text'); const blockerSubInstructionText = document.getElementById('blocker-subinstruction-text'); const blockerStatusText = document.getElementById('blocker-status-text'); const infoBarUI = document.getElementById('info-bar'); const hpBarUI = document.getElementById('hp-bar'); const hpTextUI = document.getElementById('hp-text'); const scoreboardTableBodyUI = document.querySelector('#scoreboard-table tbody'); const globalNotificationsUI = document.getElementById('global-notifications'); const deathMessageUI = document.getElementById('death-message-ui'); const respawnTimerTextUI = document.getElementById('respawn-timer-text'); const damageIndicatorUI = document.getElementById('damage-indicator-ui'); const fullscreenButton = document.getElementById('fullscreen-button'); const touchControlsUI = document.querySelector('.touch-controls-container'); const joystickArea = document.getElementById('joystick-area'); const joystickKnob = document.getElementById('joystick-knob'); const shootButtonArea = document.getElementById('shoot-button-area'); const orientationBlockerUI = document.getElementById('orientation-blocker'); const playerNameInput = document.getElementById('player-name-input'); const submitNameButton = document.getElementById('submit-name-button'); const startGameButton = document.getElementById('start-game-button');
        const damageArrowUp = document.getElementById('damage-arrow-up'); const damageArrowDown = document.getElementById('damage-arrow-down'); const damageArrowLeft = document.getElementById('damage-arrow-left'); const damageArrowRight = document.getElementById('damage-arrow-right');
        let localPlayerName = ""; let joystickActive = false, joystickTouchId = null, joystickCenterX, joystickCenterY; let lookActive = false, lookTouchId = null, lastLookX, lastLookY; let gameStarted = false, onMobile, gamePaused = false, localPlayerIsAlive = true; let isLandscape = false; let socket; let myPlayerId; let otherPlayers = {}; let clientOrbs = {}; let clientPlanets = {}; let localProjectiles = []; let remoteProjectiles = {};
        const PROJECTILE_SPEED = 150; const PROJECTILE_LIFESPAN = 1.5; const PROJECTILE_RADIUS = 0.3; const ORB_RADIUS_CLIENT = 2.0; let commonShipMaterials; const INTERPOLATION_FACTOR = 0.15; let playerInitializedOnServer = false; let lastShotTimeClient = 0; const SHOT_COOLDOWN_CLIENT = 150; let isShooting = false; let shootIntervalId = null; const PLAYER_RESPAWN_DELAY = 3000; const NOTIFICATION_TIMEOUT = 4000; const ASTEROID_COUNT_PER_RING = 250;

        let backgroundMusic, shootSFXPool = [], explosionSFX, healSFX;
        const MAX_SHOOT_SFX_INSTANCES = 5; // Jumlah instance audio tembakan untuk dimainkan bersamaan
        const SFX_MAX_HEARING_DISTANCE = 250; // Jarak maks suara terdengar
        const SFX_FULL_VOLUME_DISTANCE = 30;  // Jarak suara terdengar penuh
        const SFX_BASE_VOLUME_SHOOT = 0.6;    // Volume dasar untuk SFX tembak
        const SFX_BASE_VOLUME_EXPLOSION = 0.7;
        const SFX_BASE_VOLUME_HEAL = 0.8;
        const SFX_VOLUME_LOCAL_SHOOT = 0.4; // Volume tembakan sendiri agar tidak terlalu keras

        init(); animate();

        function initAudio() {
            backgroundMusic = new Audio('sounds/calm-space-music-312291.mp3');
            backgroundMusic.loop = true;
            backgroundMusic.volume = 0.3;

            for (let i = 0; i < MAX_SHOOT_SFX_INSTANCES; i++) {
                const sfx = new Audio('sounds/laser-104024.mp3');
                sfx.volume = SFX_BASE_VOLUME_SHOOT;
                shootSFXPool.push(sfx);
            }

            explosionSFX = new Audio('sounds/explode3-87806.mp3');
            explosionSFX.volume = SFX_BASE_VOLUME_EXPLOSION;

            healSFX = new Audio('sounds/heal_sfx.mp3');
            healSFX.volume = SFX_BASE_VOLUME_HEAL;
        }

        function playSFXFromPool(pool, volume = 1.0) {
            if (!pool || pool.length === 0) return;
            let sfxToPlay = pool.find(sfx => sfx.paused || sfx.ended);
            if (!sfxToPlay) { // Jika semua sedang sibuk, ambil yang pertama (akan memotong suara sebelumnya)
                sfxToPlay = pool[0];
            }
            sfxToPlay.currentTime = 0;
            sfxToPlay.volume = Math.max(0, Math.min(1, volume)); // Pastikan volume antara 0 dan 1
            sfxToPlay.play().catch(e => {});
        }


        function playShootSFX(isLocalPlayer = false, sourcePosition = null) {
            let volume = SFX_BASE_VOLUME_SHOOT;
            if (isLocalPlayer) {
                volume = SFX_VOLUME_LOCAL_SHOOT;
            } else if (sourcePosition && playerShip) {
                const distance = playerShip.position.distanceTo(sourcePosition);
                if (distance > SFX_MAX_HEARING_DISTANCE) {
                    return; // Terlalu jauh untuk didengar
                }
                // Model atenuasi linear sederhana
                const volumeFactor = 1.0 - Math.max(0, Math.min(1, (distance - SFX_FULL_VOLUME_DISTANCE) / (SFX_MAX_HEARING_DISTANCE - SFX_FULL_VOLUME_DISTANCE)));
                volume = SFX_BASE_VOLUME_SHOOT * volumeFactor;
            }
            playSFXFromPool(shootSFXPool, volume);
        }


        function playExplosionSFX(sourcePosition = null) {
            let volume = SFX_BASE_VOLUME_EXPLOSION;
             if (sourcePosition && playerShip) {
                const distance = playerShip.position.distanceTo(sourcePosition);
                if (distance > SFX_MAX_HEARING_DISTANCE * 1.5) return; // Ledakan bisa terdengar lebih jauh
                const volumeFactor = 1.0 - Math.max(0, Math.min(1, (distance - SFX_FULL_VOLUME_DISTANCE) / (SFX_MAX_HEARING_DISTANCE * 1.5 - SFX_FULL_VOLUME_DISTANCE)));
                volume = SFX_BASE_VOLUME_EXPLOSION * volumeFactor;
            }
            if (explosionSFX) { // Ledakan bisa lebih penting, jadi mainkan saja
                const sfx = explosionSFX.cloneNode(); // Clone untuk multiple explosions
                sfx.volume = Math.max(0, Math.min(1, volume));
                sfx.play().catch(e => {});
            }
        }
        function playHealSFX() { if (healSFX) { healSFX.currentTime = 0; healSFX.volume = SFX_BASE_VOLUME_HEAL; healSFX.play().catch(e => {}); } }
        function startBackgroundMusic() { if (backgroundMusic && backgroundMusic.paused) { backgroundMusic.play().catch(e => {}); } }
        function stopBackgroundMusic() { if (backgroundMusic) { backgroundMusic.pause(); backgroundMusic.currentTime = 0; } }

        function isMobileDevice() { let check = false; (function(a){if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|rim)|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4))) check = true;})(navigator.userAgent||navigator.vendor||window.opera); return check || (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1); }
        function checkOrientationAndNotify() { if (!onMobile) { isLandscape = true; orientationBlockerUI.style.display = 'none'; if (gamePaused && gameStarted) resumeGame(); return true; } if (window.matchMedia("(orientation: landscape)").matches) { isLandscape = true; orientationBlockerUI.style.display = 'none'; if (gamePaused && gameStarted) resumeGame(); } else { isLandscape = false; orientationBlockerUI.style.display = 'flex'; if (gameStarted && !gamePaused) pauseGame(true); } return isLandscape; }
        function validateNameInput() { const name = playerNameInput.value.trim(); if (name.length >= 3 && name.length <= 15) { if (document.getElementById('name-input-container').style.display !== 'none') { blockerInstructionText.textContent = "Nama valid. Klik 'Set Nama'."; } else { startGameButton.disabled = false; blockerInstructionText.textContent = `Nama: ${localPlayerName}. Klik "Mulai!"`;} } else { startGameButton.disabled = true; if (document.getElementById('name-input-container').style.display !== 'none') { if (name.length === 0) { blockerInstructionText.textContent = "Masukkan nama."; } else if (name.length < 3) { blockerInstructionText.textContent = "Nama min 3 karakter."; } else { blockerInstructionText.textContent = "Nama maks 15 karakter."; }} } }
        function handleSubmitName() { const name = playerNameInput.value.trim(); if (name.length >= 3 && name.length <= 15) { localPlayerName = name; document.getElementById('name-input-container').style.display = 'none'; blockerInstructionText.textContent = `Nama: ${localPlayerName}. Klik "Mulai!"`; blockerSubInstructionText.textContent = onMobile ? "(Pastikan lanskap)" : "(W/S/Mouse, Klik Kiri Tahan: Tembak)"; startGameButton.disabled = false; } else { validateNameInput(); playerNameInput.focus(); } }
        function updateHpUI(hp, maxHp) { localPlayerHp = hp; localPlayerMaxHp = maxHp; const percentage = Math.max(0, (hp / maxHp) * 100); hpBarUI.style.width = `${percentage}%`; hpTextUI.textContent = `HP: ${Math.max(0, hp)}/${maxHp}`; if (percentage < 30) hpBarUI.style.backgroundColor = '#FF4500'; else if (percentage < 60) hpBarUI.style.backgroundColor = '#FFD700'; else hpBarUI.style.backgroundColor = '#4CAF50'; }
        function updateScoreboardUI(scoreboardData) { scoreboardTableBodyUI.innerHTML = ''; scoreboardData.forEach(p => { const row = scoreboardTableBodyUI.insertRow(); row.insertCell().textContent = p.name + (p.id === myPlayerId ? " (You)" : ""); row.insertCell().textContent = p.kills; row.insertCell().textContent = p.deaths; if (!p.isAlive) row.style.color = "#aaa"; if (p.id === myPlayerId) row.style.fontWeight = "bold"; }); }
        function showDamageIndicator() { damageIndicatorUI.style.opacity = 1; setTimeout(() => { damageIndicatorUI.style.opacity = 0; }, 150); }
        let respawnInterval; function showDeathMessage(killerName, respawnDelay) { deathMessageUI.innerHTML = `DIELIMINASI OLEH ${killerName || "DUNIA INI"}!<br><span id="respawn-timer-text">Respawn dalam ${Math.ceil(respawnDelay/1000)}s</span>`; deathMessageUI.style.display = 'block'; let timeLeft = respawnDelay; if(respawnInterval) clearInterval(respawnInterval); respawnInterval = setInterval(() => { timeLeft -= 1000; if (timeLeft <=0) { deathMessageUI.style.display = 'none'; clearInterval(respawnInterval); } else { const timerTextElem = document.getElementById('respawn-timer-text'); if(timerTextElem) timerTextElem.textContent = `Respawn dalam ${Math.ceil(timeLeft/1000)}s`; } }, 1000); }
        function showGlobalNotification(message) { const notifElement = document.createElement('div'); notifElement.className = 'notification-item'; notifElement.textContent = message; globalNotificationsUI.appendChild(notifElement); setTimeout(() => { notifElement.classList.add('fade-out'); setTimeout(() => { if(notifElement.parentNode) notifElement.parentNode.removeChild(notifElement); }, 500); }, NOTIFICATION_TIMEOUT); }
        function showDamageDirection(sourcePosition) { if (!playerShip || !camera || !localPlayerIsAlive) return; const playerPos = playerShip.position.clone(); const dirToSource = sourcePosition.clone().sub(playerPos).normalize(); const camInverseQuaternion = camera.quaternion.clone().invert(); const localDirToSource = dirToSource.clone().applyQuaternion(camInverseQuaternion); damageArrowUp.style.opacity = '0'; damageArrowDown.style.opacity = '0'; damageArrowLeft.style.opacity = '0'; damageArrowRight.style.opacity = '0'; const angleThreshold = 0.707; if (localDirToSource.z > angleThreshold) { /* Depan */ } else if (localDirToSource.z < -angleThreshold) { damageArrowDown.style.opacity = '1'; } else if (localDirToSource.x > angleThreshold) { damageArrowRight.style.opacity = '1'; } else if (localDirToSource.x < -angleThreshold) { damageArrowLeft.style.opacity = '1'; } else { if (Math.abs(localDirToSource.x) > Math.abs(localDirToSource.z)) { if (localDirToSource.x > 0) damageArrowRight.style.opacity = '1'; else damageArrowLeft.style.opacity = '1'; } else { if (localDirToSource.z < 0) damageArrowDown.style.opacity = '1'; } } setTimeout(() => { damageArrowUp.style.opacity = '0'; damageArrowDown.style.opacity = '0'; damageArrowLeft.style.opacity = '0'; damageArrowRight.style.opacity = '0'; }, 400); }

        function initMultiplayer() {
            socket = io();
            socket.on('connect', () => { myPlayerId = socket.id; console.log("Socket connected:", myPlayerId); blockerStatusText.textContent = "Terhubung. Set nama."; });
            socket.on('currentGameState', (state) => { console.log("currentGameState:", state); myPlayerId = state.myId; for (const playerId in state.players) { const playerData = state.players[playerId]; if (playerId === myPlayerId) { updateHpUI(playerData.hp, playerData.maxHp); localPlayerIsAlive = playerData.isAlive; if (playerShip && !playerShip.getObjectByName("playerNameSprite")) { addNameToShip(playerShip, playerData.name || localPlayerName, true); } playerInitializedOnServer = true; if (!gameStarted && localPlayerIsAlive) { startGameSequence(); } else if (!localPlayerIsAlive && !gameStarted) { playerShip.visible = false; showDeathMessage("Sesi Lalu", PLAYER_RESPAWN_DELAY); }} else { addOtherPlayerToScene(playerData); }} state.orbs.forEach(spawnOrbInScene); if (state.planets) { state.planets.forEach(spawnPlanetFromData);} if (state.scoreboard) { updateScoreboardUI(state.scoreboard); } else if (state.players) { updateScoreboardUI(Object.values(state.players).map(p=>({id: p.id, name:p.name, kills:p.kills, deaths:p.deaths, isAlive: p.isAlive})));} if (!state.players[myPlayerId] && !gameStarted) { blockerStatusText.textContent = "Menunggu konfirmasi..."; } });
            socket.on('playerJoined', (playerData) => { console.log("Joined:", playerData); if (playerData.id !== myPlayerId) addOtherPlayerToScene(playerData); showGlobalNotification(`${playerData.name} bergabung!`); });
            socket.on('playerMoved', (playerData) => { if (otherPlayers[playerData.id] && otherPlayers[playerData.id].userData) { if(!otherPlayers[playerData.id].userData.targetPosition) otherPlayers[playerData.id].userData.targetPosition = new THREE.Vector3(); if(!otherPlayers[playerData.id].userData.targetQuaternion) otherPlayers[playerData.id].userData.targetQuaternion = new THREE.Quaternion(); otherPlayers[playerData.id].userData.targetPosition.set(playerData.x, playerData.y, playerData.z); const tQY = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), playerData.yaw); const tQP = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), playerData.pitch); otherPlayers[playerData.id].userData.targetQuaternion.copy(tQY.multiply(tQP));} });
            socket.on('orbSpawned', spawnOrbInScene);
            socket.on('playerHealed', (data) => { playHealSFX(); if (clientOrbs[data.orbId]) { scene.remove(clientOrbs[data.orbId]); clientOrbs[data.orbId].geometry.dispose(); clientOrbs[data.orbId].material.dispose(); delete clientOrbs[data.orbId]; } if (data.playerId === myPlayerId) { updateHpUI(data.newHp, localPlayerMaxHp); } else if (otherPlayers[data.playerId]) { /* TODO: Visual feedback heal pemain lain jika perlu */ } });
            socket.on('playerLeft', (playerId) => { let playerName = "Seorang pemain"; if (otherPlayers[playerId]) { const playerShipObject = otherPlayers[playerId]; const nameSprite = playerShipObject.getObjectByName("playerNameSprite"); if (nameSprite && nameSprite.userData && nameSprite.userData.playerNameText) { playerName = nameSprite.userData.playerNameText; } else if (playerShipObject.userData && playerShipObject.userData.name) { playerName = playerShipObject.userData.name; } console.log("Left:", playerId, "Name:", playerName); const shipToRemove = otherPlayers[playerId]; shipToRemove.traverse(child => { if (child.isMesh) { if(child.geometry) child.geometry.dispose(); if (child.material) { if (child.material.isMaterial) child.material.dispose(); else if (Array.isArray(child.material)) child.material.forEach(m => m.dispose()); } } if (child.name === "playerNameSprite") { if (child.material.map) child.material.map.dispose(); child.material.dispose(); } }); scene.remove(shipToRemove); delete otherPlayers[playerId]; } showGlobalNotification(`${playerName} keluar.`);});
            socket.on('playerDamaged', (data) => { if (data.playerId === myPlayerId) { updateHpUI(data.newHp, localPlayerMaxHp); showDamageIndicator(); if(data.damageSourcePosition) showDamageDirection(new THREE.Vector3(data.damageSourcePosition.x, data.damageSourcePosition.y, data.damageSourcePosition.z)); } const targetShip = data.playerId === myPlayerId ? playerShip : otherPlayers[data.playerId]; if (targetShip && data.shotImpactPosition) { spawnImpactEffect(new THREE.Vector3(data.shotImpactPosition.x, data.shotImpactPosition.y, data.shotImpactPosition.z)); } });
            socket.on('playerDied', (data) => { const deathPos = new THREE.Vector3(data.deathPosition.x, data.deathPosition.y, data.deathPosition.z); playExplosionSFX(deathPos); const shipToRemove = data.playerId === myPlayerId ? playerShip : otherPlayers[data.playerId]; if (shipToRemove) { spawnExplosion(deathPos); shipToRemove.visible = false; if (data.playerId === myPlayerId) { localPlayerIsAlive = false; moveForward = moveBackward = false; isShooting = false; if(shootIntervalId) clearInterval(shootIntervalId); showDeathMessage(data.killerName, PLAYER_RESPAWN_DELAY); if (!onMobile && document.pointerLockElement) document.exitPointerLock(); } } });
            socket.on('globalDeathNotification', (data) => { showGlobalNotification(`${data.victimName} dieliminasi oleh ${data.killerName}`); });
            socket.on('playerRespawned', (playerData) => { if (playerData.id === myPlayerId) { localPlayerIsAlive = true; playerShip.position.set(playerData.x, playerData.y, playerData.z); shipYaw = playerData.yaw; shipPitch = playerData.pitch; playerShip.quaternion.identity(); updateHpUI(playerData.hp, playerData.maxHp); playerShip.visible = true; deathMessageUI.style.display = 'none'; if(respawnInterval) clearInterval(respawnInterval); if (!gamePaused && gameStarted && !onMobile) { document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock; if(document.body.requestPointerLock) document.body.requestPointerLock(); }} else if (otherPlayers[playerData.id]) { const otherShip = otherPlayers[playerData.id]; otherShip.position.set(playerData.x, playerData.y, playerData.z); const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), playerData.yaw); const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), playerData.pitch); otherShip.quaternion.copy(qYaw.multiply(qPitch)); otherShip.userData.targetPosition.copy(otherShip.position); otherShip.userData.targetQuaternion.copy(otherShip.quaternion); otherShip.visible = true; } else { addOtherPlayerToScene(playerData); } });
            socket.on('updateScoreboard', updateScoreboardUI);
            socket.on('projectileFired', (data) => { if (data.shooterId !== myPlayerId) { const sourcePos = new THREE.Vector3(data.startPosition.x, data.startPosition.y, data.startPosition.z); spawnRemoteProjectile(data); playShootSFX(false, sourcePos); } });
            socket.on('disconnect', () => { console.log("Disconnected."); playerInitializedOnServer = false; for (const id in otherPlayers) { const shipToRemove = otherPlayers[id]; shipToRemove.traverse(child => { if (child.isMesh) { if(child.geometry) child.geometry.dispose(); if (child.material) { if (child.material.isMaterial) child.material.dispose(); else if (Array.isArray(child.material)) child.material.forEach(m => m.dispose()); } } }); scene.remove(otherPlayers[id]); } otherPlayers = {}; if (gameStarted) pauseGame(false, "Terputus."); blockerStatusText.textContent = "Koneksi terputus."; startGameButton.disabled = true; stopBackgroundMusic(); });
        }
        function createNameLabelSprite(text, isSelf = false) { const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const canvasFontSize = 96; const fontWeight = 'bold'; const fontFamily = 'Arial'; const font = `${fontWeight} ${canvasFontSize}px ${fontFamily}`; context.font = font; const textMetrics = context.measureText(text); const textWidthOnCanvas = textMetrics.width; const paddingOnCanvas = 30; canvas.width = textWidthOnCanvas + paddingOnCanvas * 2; canvas.height = canvasFontSize + paddingOnCanvas * 2; context.font = font; context.textAlign = 'center'; context.textBaseline = 'middle'; const strokeColor = 'rgba(0, 0, 0, 0.8)'; const strokeWidth = canvasFontSize / 18; context.miterLimit = 2; context.lineJoin = 'round'; context.strokeStyle = strokeColor; context.lineWidth = strokeWidth; context.strokeText(text, canvas.width / 2, canvas.height / 2); context.fillStyle = isSelf ? 'rgba(190, 230, 255, 1)' : 'rgba(255, 220, 200, 1)'; context.fillText(text, canvas.width / 2, canvas.height / 2); const texture = new THREE.CanvasTexture(canvas); texture.minFilter = THREE.LinearFilter; texture.magFilter = THREE.LinearFilter; texture.generateMipmaps = true; texture.needsUpdate = true; const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, depthWrite: false, transparent: true, sizeAttenuation: true, }); const sprite = new THREE.Sprite(spriteMaterial); sprite.scale.set(canvas.width / canvas.height, 1, 1); sprite.renderOrder = 1; sprite.userData.playerNameText = text; return sprite; }
        function addNameToShip(shipObject, name, isSelf = false) { if (!name || !shipObject) return; const oldNameSprite = shipObject.getObjectByName("playerNameSprite"); if (oldNameSprite) { shipObject.remove(oldNameSprite); if (oldNameSprite.material.map) oldNameSprite.material.map.dispose(); oldNameSprite.material.dispose(); } const nameSprite = createNameLabelSprite(name, isSelf); nameSprite.name = "playerNameSprite"; const desiredNameTextHeightInWorld = 0.8; const canvasAspectRatio = nameSprite.material.map.image.width / nameSprite.material.map.image.height; nameSprite.scale.set(desiredNameTextHeightInWorld * canvasAspectRatio, desiredNameTextHeightInWorld, 1.0); let shipHeightReference = 1.0 * (shipObject.scale.y || 1); const bodyMesh = shipObject.children.find(child => child.isMesh && child.geometry instanceof THREE.BoxGeometry && Math.abs(child.geometry.parameters.height - 1.0) < 0.01); if (bodyMesh) { shipHeightReference = bodyMesh.geometry.parameters.height * (shipObject.scale.y || 1); } const spriteWorldHeight = nameSprite.scale.y; nameSprite.position.y = (shipHeightReference / 2) + (spriteWorldHeight / 2) + 1.1; shipObject.add(nameSprite); }
        function buildShipModel(targetGroup, materials, isOtherPlayer = false) { const bodyWidth = 1.8, bodyHeight = 1.0, bodyDepth = 3.5; let bodyMaterialToUse = materials.body; if (isOtherPlayer) { bodyMaterialToUse = materials.body.clone(); bodyMaterialToUse.color.setHex(Math.random() * 0xffffff); } targetGroup.add(new THREE.Mesh(new THREE.BoxGeometry(bodyWidth, bodyHeight, bodyDepth), bodyMaterialToUse)); const cockpit = new THREE.Mesh(new THREE.SphereGeometry(0.6, 16, 8, 0, Math.PI*2, 0, Math.PI/2), materials.cockpit.clone()); cockpit.position.set(0, 0.3, 1.0); cockpit.rotation.x = -Math.PI/18; targetGroup.add(cockpit); const singleWingLength = 1.9; const wingDepth = 1.5; const wingThickness = 0.2; const singleWingGeo = new THREE.BoxGeometry(singleWingLength, wingThickness, wingDepth); const leftWing = new THREE.Mesh(singleWingGeo, materials.wing.clone()); leftWing.position.set(-(bodyWidth/2 + singleWingLength / 2), 0, 0.2); targetGroup.add(leftWing); const rightWing = new THREE.Mesh(singleWingGeo, materials.wing.clone()); rightWing.position.set((bodyWidth/2 + singleWingLength / 2), 0, 0.2); targetGroup.add(rightWing); const engine = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.5, 1.5, 16), materials.engine.clone()); engine.position.set(0, -0.1, -2.0); engine.rotation.x = Math.PI/2; targetGroup.add(engine); const eGlow = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.05, 0.5, 12), materials.engineGlow.clone()); eGlow.position.set(0, -0.1, -2.6); eGlow.rotation.x = Math.PI/2; targetGroup.add(eGlow); }
        function addOtherPlayerToScene(playerData) { let otherShip = otherPlayers[playerData.id]; if (otherShip) { otherShip.visible = playerData.isAlive; if (playerData.name && playerData.name !== otherShip.userData.name) { addNameToShip(otherShip, playerData.name, false); otherShip.userData.name = playerData.name; } return; } otherShip = new THREE.Group(); buildShipModel(otherShip, commonShipMaterials, true); otherShip.scale.set(onMobile ? 0.55 : 0.65, onMobile ? 0.55 : 0.65, onMobile ? 0.55 : 0.65); otherShip.position.set(playerData.x, playerData.y, playerData.z); const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), playerData.yaw); const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), playerData.pitch); otherShip.quaternion.copy(qYaw.multiply(qPitch)); otherShip.userData.targetPosition = new THREE.Vector3().copy(otherShip.position); otherShip.userData.targetQuaternion = new THREE.Quaternion().copy(otherShip.quaternion); otherShip.userData.name = playerData.name; addNameToShip(otherShip, playerData.name, false); otherShip.visible = playerData.isAlive; scene.add(otherShip); otherPlayers[playerData.id] = otherShip; }
        function spawnOrbInScene(orbData) { if (clientOrbs[orbData.id]) return; const geometry = new THREE.SphereGeometry(ORB_RADIUS_CLIENT, onMobile?10:14, onMobile?10:14); const material = new THREE.MeshBasicMaterial({color:0x44ff44, emissive:0x33dd33, emissiveIntensity:1.8}); const orbMesh = new THREE.Mesh(geometry, material); orbMesh.position.set(orbData.x, orbData.y, orbData.z); orbMesh.userData = { id: orbData.id, initialY:orbMesh.position.y, bobSpeed:THREE.MathUtils.randFloat(0.7,1.7), bobAmplitude:THREE.MathUtils.randFloat(0.45,0.85) }; scene.add(orbMesh); clientOrbs[orbData.id] = orbMesh; }
        function spawnPlanetFromData(planetData) { if (clientPlanets[planetData.id]) return; const pRad = planetData.radius; const pGeom = new THREE.SphereGeometry(pRad, onMobile?20:28, onMobile?20:28); const pMat = new THREE.MeshStandardMaterial({ color: new THREE.Color(planetData.color), roughness: THREE.MathUtils.randFloat(0.4,0.9), metalness: THREE.MathUtils.randFloat(0.0,0.3) }); const planetMesh = new THREE.Mesh(pGeom,pMat); planetMesh.position.set(planetData.x, planetData.y, planetData.z); planetMesh.userData = { id: planetData.id, radius: pRad, hasRing: planetData.hasRing }; scene.add(planetMesh); clientPlanets[planetData.id] = planetMesh; if (planetData.hasRing) { const ringParticleCount = onMobile ? Math.floor(ASTEROID_COUNT_PER_RING / 2.5) : ASTEROID_COUNT_PER_RING; const ringMaterial = new THREE.PointsMaterial({ size: onMobile ? 0.25 : 0.4, color: 0x999999, transparent: true, opacity: 0.5, sizeAttenuation: true }); const ringParticles = []; for (let i = 0; i < ringParticleCount; i++) { const angle = Math.random() * Math.PI * 2; const radius = THREE.MathUtils.randFloat(planetData.ringMinRadius, planetData.ringMaxRadius); const x = Math.cos(angle) * radius; const z = Math.sin(angle) * radius; const y = (Math.random() - 0.5) * planetData.ringThickness * (onMobile ? 0.7 : 1); ringParticles.push(x, y, z); } const ringGeometry = new THREE.BufferGeometry(); ringGeometry.setAttribute('position', new THREE.Float32BufferAttribute(ringParticles, 3)); const ringSystem = new THREE.Points(ringGeometry, ringMaterial); ringSystem.rotation.x = Math.random() * 0.2 - 0.1; ringSystem.rotation.z = Math.random() * 0.2 - 0.1; planetMesh.add(ringSystem); } }
        function fireLocalProjectile() { if (!playerShip || !localPlayerIsAlive || Date.now() - lastShotTimeClient < SHOT_COOLDOWN_CLIENT) return; lastShotTimeClient = Date.now(); playShootSFX(true); const projectileMaterial = new THREE.MeshBasicMaterial({color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 2}); const projectileGeometry = new THREE.SphereGeometry(PROJECTILE_RADIUS, 6, 6); const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial); const offset = new THREE.Vector3(0, 0, playerShip.children[0].geometry.parameters.depth / 2 + 0.5); offset.applyQuaternion(playerShip.quaternion); projectile.position.copy(playerShip.position).add(offset); projectile.quaternion.copy(playerShip.quaternion); projectile.userData.velocity = new THREE.Vector3(0,0,1).applyQuaternion(playerShip.quaternion).multiplyScalar(PROJECTILE_SPEED); projectile.userData.spawnTime = clock.getElapsedTime(); localProjectiles.push(projectile); scene.add(projectile); socket.emit('playerShoot', { startPosition: {x: projectile.position.x, y: projectile.position.y, z: projectile.position.z}, orientation: { _x: playerShip.quaternion.x, _y: playerShip.quaternion.y, _z: playerShip.quaternion.z, _w: playerShip.quaternion.w } }); }
        function updateLocalProjectiles(deltaTime) { for (let i = localProjectiles.length - 1; i >= 0; i--) { const p = localProjectiles[i]; p.position.addScaledVector(p.userData.velocity, deltaTime); if (clock.getElapsedTime() - p.userData.spawnTime > PROJECTILE_LIFESPAN) { scene.remove(p); p.geometry.dispose(); p.material.dispose(); localProjectiles.splice(i, 1); } } }
        function spawnRemoteProjectile(data) { if(remoteProjectiles[data.projectileId]) return; const projectileMaterial = new THREE.MeshBasicMaterial({color: 0xff8800, emissive: 0xff8800, emissiveIntensity: 2}); const projectileGeometry = new THREE.SphereGeometry(PROJECTILE_RADIUS, 6, 6); const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial); projectile.position.set(data.startPosition.x, data.startPosition.y, data.startPosition.z); projectile.quaternion.set(data.orientation._x, data.orientation._y, data.orientation._z, data.orientation._w); projectile.userData.velocity = new THREE.Vector3(0,0,1).applyQuaternion(projectile.quaternion).multiplyScalar(PROJECTILE_SPEED); projectile.userData.spawnTime = clock.getElapsedTime(); projectile.userData.lifespan = data.lifespan; projectile.userData.id = data.projectileId; remoteProjectiles[data.projectileId] = projectile; scene.add(projectile); }
        function updateRemoteProjectiles(deltaTime) { for (const id in remoteProjectiles) { const p = remoteProjectiles[id]; p.position.addScaledVector(p.userData.velocity, deltaTime); if (clock.getElapsedTime() - p.userData.spawnTime > p.userData.lifespan) { scene.remove(p); p.geometry.dispose(); p.material.dispose(); delete remoteProjectiles[id]; } } }
        function spawnExplosion(position) { const numParticles = 30 + Math.floor(Math.random() * 20); const particleColors = [0xff4400, 0xff8800, 0xffcc00, 0xffee88, 0xffffff]; for (let i = 0; i < numParticles; i++) { const particleMaterial = new THREE.SpriteMaterial({ color: particleColors[Math.floor(Math.random() * particleColors.length)], blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8 + Math.random() * 0.2, depthWrite: false, sizeAttenuation: true }); const particle = new THREE.Sprite(particleMaterial); particle.position.copy(position); const baseScale = 0.3 + Math.random() * 1.2; particle.scale.set(baseScale, baseScale, 1); particle.userData.velocity = new THREE.Vector3((Math.random() - 0.5) * (30 + Math.random()*20) , (Math.random() - 0.5) * (30 + Math.random()*20), (Math.random() - 0.5) * (30 + Math.random()*20)); particle.userData.life = 0.5 + Math.random() * 0.8; particle.userData.spawnTime = clock.getElapsedTime(); particle.userData.initialScale = baseScale; scene.add(particle); } }
        function spawnImpactEffect(position) { const impactMaterial = new THREE.SpriteMaterial({ color: 0xffffaa, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false, sizeAttenuation: true, opacity: 0.9 }); const particle = new THREE.Sprite(impactMaterial); particle.position.copy(position); const scale = Math.random() * 1.0 + 0.5; particle.scale.set(scale,scale,1); scene.add(particle); setTimeout(() => { if(particle.parent) scene.remove(particle); particle.material.dispose(); }, 150); }
        function init() {
            initAudio();
            onMobile = isMobileDevice(); checkOrientationAndNotify(); window.addEventListener('orientationchange', checkOrientationAndNotify); window.addEventListener('resize', onWindowResize); scene = new THREE.Scene(); scene.background = new THREE.Color(0x000011); scene.fog = new THREE.Fog(0x000011, 120, 450); camera = new THREE.PerspectiveCamera(onMobile ? 70 : 60, window.innerWidth / window.innerHeight, 0.1, 1800); commonShipMaterials = { body: new THREE.MeshStandardMaterial({ color: 0x888899, roughness: 0.4, metalness: 0.35 }), cockpit: new THREE.MeshStandardMaterial({ color: 0x5599DD, roughness: 0.15, metalness: 0.1, transparent: true, opacity: 0.8 }), wing: new THREE.MeshStandardMaterial({ color: 0x777788, roughness: 0.5, metalness: 0.25 }), engine: new THREE.MeshStandardMaterial({ color: 0x666677, roughness: 0.6, metalness: 0.45 }), engineGlow: new THREE.MeshBasicMaterial({ color: 0xffb520, transparent:true, opacity:0.65 }) }; createPlayerShip(); playerShip.position.set(0, 5, 0); scene.add(playerShip); const initialCameraOffset = new THREE.Vector3(0, onMobile ? 3.0 : 3.8, onMobile ? -9 : -11); const cameraInitialPosition = initialCameraOffset.clone().applyQuaternion(playerShip.quaternion); cameraInitialPosition.add(playerShip.position); camera.position.copy(cameraInitialPosition); camera.lookAt(playerShip.position); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); document.body.appendChild(renderer.domElement); const ambientLight = new THREE.AmbientLight(0x707090, 1.6); scene.add(ambientLight); const sunLight = new THREE.DirectionalLight(0xffffff, 2.2); sunLight.position.set(80, 80, 80); scene.add(sunLight); initMultiplayer(); if (onMobile) { touchControlsUI.style.display = 'flex'; currentLookSensitivity = mobileLookSensitivity; blockerSubInstructionText.textContent = "(Lanskap)"; setupTouchControls(); fullscreenButton.style.display = 'none'; document.body.style.cursor = 'default'; } else { touchControlsUI.style.display = 'none'; currentLookSensitivity = desktopMouseSensitivity; blockerSubInstructionText.textContent = "(W/S/Mouse, Klik Tahan: Tembak)"; setupDesktopControls(); fullscreenButton.style.display = 'block'; document.body.style.cursor = 'crosshair'; } submitNameButton.addEventListener('click', handleSubmitName); playerNameInput.addEventListener('keyup', (event) => { if (event.key === "Enter") handleSubmitName(); validateNameInput(); }); startGameButton.addEventListener('click', handleClickToStart); fullscreenButton.addEventListener('click', toggleFullScreen); validateNameInput(); createStarfield(); window.addEventListener('resize', onWindowResize); onWindowResize(); document.addEventListener('mousedown', (event) => { if (event.button === 0 && gameStarted && localPlayerIsAlive && !gamePaused && !onMobile && document.pointerLockElement) { isShooting = true; fireLocalProjectile(); if (shootIntervalId) clearInterval(shootIntervalId); shootIntervalId = setInterval(fireLocalProjectile, SHOT_COOLDOWN_CLIENT); }}); document.addEventListener('mouseup', (event) => { if (event.button === 0 && !onMobile) { isShooting = false; if (shootIntervalId) clearInterval(shootIntervalId); }}); if(shootButtonArea) { shootButtonArea.addEventListener('touchstart', (event) => { event.preventDefault(); if(gameStarted && localPlayerIsAlive && !gamePaused && onMobile && isLandscape) { isShooting = true; fireLocalProjectile(); if (shootIntervalId) clearInterval(shootIntervalId); shootIntervalId = setInterval(fireLocalProjectile, SHOT_COOLDOWN_CLIENT);}}, {passive: false}); shootButtonArea.addEventListener('touchend', (event) => { event.preventDefault(); if(onMobile) { isShooting = false; if (shootIntervalId) clearInterval(shootIntervalId); }}, {passive: false}); shootButtonArea.addEventListener('touchcancel', (event) => { event.preventDefault(); if(onMobile) { isShooting = false; if (shootIntervalId) clearInterval(shootIntervalId); }}, {passive: false}); } }
        function createPlayerShip() { playerShip = new THREE.Group(); buildShipModel(playerShip, commonShipMaterials, false); playerShip.scale.set(onMobile ? 0.55 : 0.65, onMobile ? 0.55 : 0.65, onMobile ? 0.55 : 0.65); }
        function pauseGame(isOrientationPause = false, customMessage = "Game Dijeda") { if (gamePaused) return; gamePaused = true; blockerTitleText.textContent = "Game Dijeda"; if (isOrientationPause) { blockerInstructionText.textContent = "Putar ke Lanskap."; blockerSubInstructionText.textContent = ""; } else { blockerInstructionText.textContent = onMobile ? "TAP lanjut." : "Klik lanjut."; blockerSubInstructionText.textContent = customMessage === "Game Dijeda" ? (onMobile ? "(Joystick, Geser Kanan)" : "(W/S/Mouse, Klik Tahan)") : "";} blockerStatusText.textContent = customMessage; blocker.style.display = 'flex'; document.getElementById('name-input-container').style.display = 'none'; startGameButton.style.display = 'none'; blocker.onclick = resumeGame; if (!onMobile && document.pointerLockElement) { document.exitPointerLock(); } isShooting = false; if(shootIntervalId) clearInterval(shootIntervalId); stopBackgroundMusic(); }
        function resumeGame() { if (!gamePaused || !gameStarted) return; if (onMobile && !isLandscape) { orientationBlockerUI.style.display = 'flex'; return; } if (!localPlayerIsAlive) return; gamePaused = false; blocker.style.display = 'none'; orientationBlockerUI.style.display = 'none'; blocker.onclick = null; if (!onMobile) { document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock; if(document.body.requestPointerLock) document.body.requestPointerLock(); } startBackgroundMusic(); }
        function handleClickToStart() { if (gameStarted && gamePaused) { resumeGame(); return; } if (gameStarted && !gamePaused) return; if (!localPlayerName) { handleSubmitName(); if(!localPlayerName) return; } if (!socket || !socket.connected) { blockerStatusText.textContent = "Tidak terhubung."; return; } if (onMobile && !checkOrientationAndNotify()) return; if (onMobile) toggleFullScreenWithOrientation(); if (!playerInitializedOnServer) { console.log("Sending playerInit:", localPlayerName); socket.emit('playerInit', { name: localPlayerName }); blockerStatusText.textContent = "Inisialisasi..."; } else { startGameSequence(); } }
        function startGameSequence() { if (gameStarted) return; if (onMobile && !isLandscape) { orientationBlockerUI.style.display = 'flex'; return; } if (!localPlayerName) { blockerInstructionText.textContent = "Set nama dulu!"; document.getElementById('name-input-container').style.display = 'flex'; startGameButton.disabled = true; startGameButton.style.display = 'block'; return; } if (!localPlayerIsAlive) { console.log("Player mati, tunggu respawn."); playerShip.visible = false; return; } console.log("Starting game:", localPlayerName); gameStarted = true; gamePaused = false; blocker.style.display = 'none'; orientationBlockerUI.style.display = 'none'; infoBarUI.style.display = 'flex'; if (playerShip && !playerShip.getObjectByName("playerNameSprite") && localPlayerName) { addNameToShip(playerShip, localPlayerName, true); } if (!onMobile) { document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock; if (document.body.requestPointerLock) document.body.requestPointerLock(); } startBackgroundMusic(); }
        async function toggleFullScreenWithOrientation() { const element = document.documentElement; if (!document.fullscreenElement) { if (onMobile && element.requestFullscreen) { try { if (screen.orientation && typeof screen.orientation.lock === 'function') { await element.requestFullscreen({ navigationUI: "hide" }); await screen.orientation.lock('landscape').catch(err => {}); } else { await element.requestFullscreen({ navigationUI: "hide" }).catch(err => {}); } } catch (err) {} } } else { if (document.exitFullscreen) { await document.exitFullscreen().catch(err => {}); if (screen.orientation && typeof screen.orientation.unlock === 'function') { screen.orientation.unlock(); } } } }
        function toggleFullScreen() { toggleFullScreenWithOrientation(); }
        function setupDesktopControls() { document.addEventListener('pointerlockchange', handlePointerLockChange, false); document.addEventListener('mozpointerlockchange', handlePointerLockChange, false); document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp); }
        function handlePointerLockChange() { if (onMobile) return; if (document.pointerLockElement === document.body || document.mozPointerLockElement === document.body) { if (gameStarted && gamePaused && localPlayerIsAlive) { if (blockerStatusText.textContent.includes("Pointer Lock hilang")) { resumeGame(); } } document.addEventListener("mousemove", onDocumentMouseMove, false); } else { if (gameStarted && !gamePaused && localPlayerIsAlive) pauseGame(false, "Pointer Lock hilang."); document.removeEventListener("mousemove", onDocumentMouseMove, false); moveForward = moveBackward = false; isShooting = false; if(shootIntervalId) clearInterval(shootIntervalId); } }
        function onDocumentMouseMove(e) { if (!gameStarted || gamePaused || onMobile || !document.pointerLockElement || !localPlayerIsAlive) return; shipYaw -= e.movementX * currentLookSensitivity; shipPitch -= e.movementY * currentLookSensitivity; shipPitch = Math.max(minPitch, Math.min(maxPitch, shipPitch)); }
        function onKeyDown(event) { if (!gameStarted || gamePaused || onMobile || (!document.pointerLockElement && event.target === document.body) || !localPlayerIsAlive) { return; } if (onMobile || (!document.pointerLockElement && !gameStarted && !gamePaused)) return; switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = true; break; case 'KeyS': case 'ArrowDown': moveBackward = true; break; case 'KeyP': if(gameStarted && localPlayerIsAlive) gamePaused ? resumeGame() : pauseGame(); break; } }
        function onKeyUp(event) { if (onMobile || gamePaused || !gameStarted || !localPlayerIsAlive) return; switch (event.code) { case 'KeyW': case 'ArrowUp': moveForward = false; break; case 'KeyS': case 'ArrowDown': moveBackward = false; break; } }
        function setupTouchControls() { const joystickAreaElem = document.getElementById('joystick-area'); if(!joystickAreaElem) return; const joystickRect = joystickAreaElem.getBoundingClientRect(); joystickCenterX = joystickRect.left + joystickRect.width / 2; joystickCenterY = joystickRect.top + joystickRect.height / 2; joystickAreaElem.addEventListener('touchstart', handleJoystickStart, { passive: false }); joystickAreaElem.addEventListener('touchmove', handleJoystickMove, { passive: false }); joystickAreaElem.addEventListener('touchend', handleJoystickEnd, { passive: false }); joystickAreaElem.addEventListener('touchcancel', handleJoystickEnd, { passive: false }); document.addEventListener('touchstart', handleLookStart, { passive: false }); document.addEventListener('touchmove', handleLookMove, { passive: false }); document.addEventListener('touchend', handleLookEnd, { passive: false }); document.addEventListener('touchcancel', handleLookEnd, { passive: false }); }
        function handleJoystickStart(event) { event.preventDefault(); if (!gameStarted || gamePaused || joystickActive || !isLandscape && onMobile || !localPlayerIsAlive) return; const touch = event.changedTouches[0]; joystickTouchId = touch.identifier; joystickActive = true; updateJoystickKnob(touch.clientX, touch.clientY); }
        function handleJoystickMove(event) { event.preventDefault(); if (!gameStarted || gamePaused || !joystickActive || !isLandscape && onMobile || !localPlayerIsAlive) return; for (let i=0; i<event.changedTouches.length; i++) { const touch = event.changedTouches[i]; if (touch.identifier === joystickTouchId) { updateJoystickKnob(touch.clientX, touch.clientY); break; } } }
        function handleJoystickEnd(event) { event.preventDefault(); if (!joystickActive) return; for (let i=0; i<event.changedTouches.length; i++) { const touch = event.changedTouches[i]; if (touch.identifier === joystickTouchId) { joystickActive = false; joystickTouchId = null; resetJoystickKnob(); moveForward = moveBackward = false; break; } } }
        function updateJoystickKnob(clientX, clientY) { const joystickAreaElem = document.getElementById('joystick-area'); const joystickKnobElem = document.getElementById('joystick-knob'); if(!joystickAreaElem || !joystickKnobElem) return; const rect = joystickAreaElem.getBoundingClientRect(); const currentJoystickCenterX = rect.left + rect.width / 2; const currentJoystickCenterY = rect.top + rect.height / 2; let dx = clientX - currentJoystickCenterX; let dy = clientY - currentJoystickCenterY; const distance = Math.sqrt(dx*dx + dy*dy); const currentJoystickMaxDist = (rect.width / 2) - (joystickKnobElem.offsetWidth / 2); if (distance > currentJoystickMaxDist) { dx = (dx/distance)*currentJoystickMaxDist; dy = (dy/distance)*currentJoystickMaxDist; } joystickKnobElem.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`; const deadZoneY = currentJoystickMaxDist * 0.20; const normalizedY = Math.abs(dy) < deadZoneY ? 0 : dy / currentJoystickMaxDist; moveForward = false; moveBackward = false; if (normalizedY < -0.2) { moveForward = true; } else if (normalizedY > 0.2) { moveBackward = true; } }
        function resetJoystickKnob() { const knob = document.getElementById('joystick-knob'); if (knob) knob.style.transform = 'translate(-50%, -50%)'; }
        function handleLookStart(event) { if (!gameStarted || gamePaused || lookActive || !isLandscape && onMobile || !localPlayerIsAlive) return; const touch = event.changedTouches[0]; if (touch.clientX > window.innerWidth / 2.5 && event.target !== joystickArea && !joystickArea.contains(event.target) && event.target !== shootButtonArea && !shootButtonArea.contains(event.target) ) { event.preventDefault(); lookTouchId = touch.identifier; lookActive = true; lastLookX = touch.clientX; lastLookY = touch.clientY; } }
        function handleLookMove(event) { if (!gameStarted || gamePaused || !lookActive || !isLandscape && onMobile || !localPlayerIsAlive) return; for (let i=0; i<event.changedTouches.length; i++) { const touch = event.changedTouches[i]; if (touch.identifier === lookTouchId) { event.preventDefault(); const deltaX = touch.clientX - lastLookX; const deltaY = touch.clientY - lastLookY; shipYaw -= deltaX * currentLookSensitivity; shipPitch -= deltaY * currentLookSensitivity; shipPitch = Math.max(minPitch, Math.min(maxPitch, shipPitch)); lastLookX = touch.clientX; lastLookY = touch.clientY; break; } } }
        function handleLookEnd(event) { if (!lookActive) return; for (let i=0; i<event.changedTouches.length; i++) { const touch = event.changedTouches[i]; if (touch.identifier === lookTouchId) { event.preventDefault(); lookActive = false; lookTouchId = null; break; } } }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); if (onMobile) { const joystickAreaElem = document.getElementById('joystick-area'); if(joystickAreaElem) {const joystickRect = joystickAreaElem.getBoundingClientRect(); joystickCenterX = joystickRect.left + joystickRect.width / 2; joystickCenterY = joystickRect.top + joystickRect.height / 2;} checkOrientationAndNotify(); } }
        function createStarfield() { const sGeom = new THREE.BufferGeometry(), sMat = new THREE.PointsMaterial({color:0xffffff,size:onMobile?0.4:0.5,sizeAttenuation:true}); const sVerts = []; for (let i=0; i<(onMobile?8000:12000); i++) { sVerts.push(THREE.MathUtils.randFloatSpread(worldSize*4), THREE.MathUtils.randFloatSpread(worldSize*4), THREE.MathUtils.randFloatSpread(worldSize*4)); } sGeom.setAttribute('position', new THREE.Float32BufferAttribute(sVerts,3)); scene.add(new THREE.Points(sGeom,sMat)); }
        function updateOrbs(deltaTime) { if (gamePaused && onMobile && !isLandscape) {} else { const time = clock.getElapsedTime(); for (const orbId in clientOrbs) { const o = clientOrbs[orbId]; if(o && o.userData) { o.position.y = o.userData.initialY + Math.sin(time*o.userData.bobSpeed)*o.userData.bobAmplitude; o.rotation.x += 0.3*deltaTime; o.rotation.y += 0.5*deltaTime; } } } }
        let lastUpdateTime = 0; const updateInterval = 1000 / 20; let lastPlanetCollisionCheckTime = 0; const planetCollisionCheckInterval = 250;
        function updateShipAndCamera(deltaTime) { if (!playerShip || !gameStarted || gamePaused || (onMobile && !isLandscape) || !localPlayerIsAlive) return; const qYaw = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), shipYaw); const qPitch = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1,0,0), shipPitch); playerShip.quaternion.copy(qYaw.multiply(qPitch)); const actualSpeed = playerSpeed * deltaTime; if (moveForward) playerShip.translateZ(actualSpeed); if (moveBackward) playerShip.translateZ(-actualSpeed); const limit = worldSize*1.6; playerShip.position.clamp(new THREE.Vector3(-limit,-limit/1.5,-limit), new THREE.Vector3(limit,limit,limit)); const camOffset = new THREE.Vector3(0, (onMobile?1.8:2.4), (onMobile?-7.5:-9.5)); const worldCamOffset = camOffset.clone().applyQuaternion(playerShip.quaternion); const camTargetPos = new THREE.Vector3().copy(playerShip.position).add(worldCamOffset); camera.position.lerp(camTargetPos, onMobile ? 0.12 : 0.1); const lookAtTgt = new THREE.Vector3(0,0.5,5).applyQuaternion(playerShip.quaternion).add(playerShip.position); camera.lookAt(lookAtTgt); const now = Date.now(); if (socket && socket.connected && (now - lastUpdateTime > updateInterval)) { socket.emit('playerStateUpdate', { x: playerShip.position.x, y: playerShip.position.y, z: playerShip.position.z, yaw: shipYaw, pitch: shipPitch, }); lastUpdateTime = now; } }
        function checkCollisions() { if (!playerShip || !gameStarted || gamePaused || (onMobile && !isLandscape) || !socket || !localPlayerIsAlive) return; for (const orbId in clientOrbs) { const orbMesh = clientOrbs[orbId]; if (orbMesh && playerShip.position.distanceTo(orbMesh.position) < playerRadius + ORB_RADIUS_CLIENT) { socket.emit('orbCollected', orbId); break; } } const now = Date.now(); if (now - lastPlanetCollisionCheckTime > planetCollisionCheckInterval) { lastPlanetCollisionCheckTime = now; for (const planetId in clientPlanets) { const planetMesh = clientPlanets[planetId]; if (planetMesh && playerShip.position.distanceTo(planetMesh.position) < playerRadius + planetMesh.userData.radius * 0.9) { socket.emit('playerHitPlanet', { planetId: planetMesh.userData.id }); break; } } } }
        function updateOtherPlayers(deltaTime) { if (gamePaused) return; for (const id in otherPlayers) { const ship = otherPlayers[id]; if (ship.userData && ship.userData.targetPosition && ship.userData.targetQuaternion) { ship.position.lerp(ship.userData.targetPosition, INTERPOLATION_FACTOR); ship.quaternion.slerp(ship.userData.targetQuaternion, INTERPOLATION_FACTOR); } } }
        function animate() {
            requestAnimationFrame(animate); const deltaTime = clock.getDelta();
            if (!gamePaused && gameStarted && (!onMobile || isLandscape)) { if(localPlayerIsAlive) updateShipAndCamera(deltaTime); checkCollisions(); updateLocalProjectiles(deltaTime); updateRemoteProjectiles(deltaTime); }
            scene.children.forEach(child => { if (child.isSprite && child.userData.velocity && child.userData.life && child.userData.initialScale) { const elapsedTime = clock.getElapsedTime() - child.userData.spawnTime; child.position.addScaledVector(child.userData.velocity, deltaTime); const lifeRatio = Math.max(0, 1 - elapsedTime / child.userData.life); child.material.opacity = lifeRatio * (0.8 + Math.random()*0.2); child.scale.setScalar(child.userData.initialScale * (0.5 + lifeRatio * 0.5)); if(lifeRatio <= 0 && child.parent) { scene.remove(child); child.material.dispose(); if(child.material.map && child.material.map.dispose) child.material.map.dispose(); }} });
            updateOrbs(deltaTime); updateOtherPlayers(deltaTime); renderer.render(scene, camera);
        }
    </script>
</body>
</html>
